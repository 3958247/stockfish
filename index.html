<!DOCTYPE html>
<html>
<body>
  <script>
/**************************************************************
 *                      CONSTANTS
 **************************************************************/

/**
 * Possible states of the game.
 * @readonly
 * @enum {string}
 */
const STATES = Object.freeze({
  CONSTRUCTING: "constructing",
  THINKING: "thinking",
  POST_THINKING: "postThinking",
});

/**
 * Base timeout durations (in milliseconds).
 * @readonly
 */
const TIMEOUTS = Object.freeze({
  BASE_COORD_VALIDATE: 1000,
  BASE_ENGINE_APPROVE: 2000,
  BASE_INPUT_UNLOCK: 1000,
  BASE_VOICE: 300,
});

const GAME_SPEED = 1.0;
const SPEECH_RATE = 1.0 * GAME_SPEED;

const MAX_COORD_VALUE = 8;

const COORD_VALIDATE_DELAY = TIMEOUTS.BASE_COORD_VALIDATE / GAME_SPEED;
const ENGINE_APPROVE_DELAY = TIMEOUTS.BASE_ENGINE_APPROVE / GAME_SPEED;
const INPUT_UNLOCK_DELAY   = TIMEOUTS.BASE_INPUT_UNLOCK / GAME_SPEED;
const VOICE_DELAY          = TIMEOUTS.BASE_VOICE / SPEECH_RATE;

/**************************************************************
 *                      UTILS
 **************************************************************/

/**
 * Sleep for a given duration.
 * @param {number} ms - Duration in milliseconds.
 * @returns {Promise<void>}
 */
const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

/**
 * Converts a string to NATO phonetic alphabet notation.
 * Letters are wrapped in `*` for special pronunciation.
 * @param {string} str - The input string.
 * @returns {string} - NATO phonetic representation.
 */
const toNatoString = (str) => {
  const nato = {
    a: "alpha", b: "bravo", c: "charlie", d: "delta",
    e: "echo", f: "foxtrot", g: "golf", h: "hotel",
    i: "india", j: "juliett", k: "kilo", l: "lima",
    m: "mike", n: "november", o: "oscar", p: "papa",
    q: "quebec", r: "romeo", s: "sierra", t: "tango",
    u: "uniform", v: "victor", w: "whiskey", x: "xray",
    y: "yankee", z: "zulu"
  };

  return str
    .toLowerCase()
    .split("")
    .map(ch => nato[ch] ? `*${nato[ch]}*` : ch)
    .join("");
};

/**************************************************************
 *                      SPEECH MANAGER
 **************************************************************/

/**
 * Manages speech synthesis for the game.
 */
class SpeechManager {
  constructor() {
    /** @type {number} Unique session id to prevent speech overlap */
    this.sessionId = 0;
    /** @type {ReturnType<typeof setTimeout>|null} Timeout for character-by-character speech */
    this.charTimeout = null;
    /** @type {string} Last spoken text */
    this.lastSpoken = "";
  }

  /**
   * Speak a text string with optional character-by-character delays.
   * @param {string} text - The text to speak.
   * @param {number} [delay=VOICE_DELAY] - Delay between characters in milliseconds.
   */
  speak(text, delay = VOICE_DELAY) {
    if (!text) return;

    this.lastSpoken = text;
    console.log(text);

    window.speechSynthesis.cancel();
    this.sessionId++;
    const session = this.sessionId;

    if (this.charTimeout) clearTimeout(this.charTimeout);

    const parts = text.split("*");
    let pIndex = 0;

    const speakNextPart = () => {
      if (session !== this.sessionId || pIndex >= parts.length) return;

      const part = parts[pIndex];
      const isNormal = (pIndex % 2 === 1);
      pIndex++;

      if (isNormal) {
        const utter = new SpeechSynthesisUtterance(part);
        utter.rate = SPEECH_RATE;
        utter.onend = speakNextPart;
        setTimeout(() => window.speechSynthesis.speak(utter), 0);
      } else {
        let cIndex = 0;
        const speakNextChar = () => {
          if (session !== this.sessionId || cIndex >= part.length) {
            speakNextPart();
            return;
          }

          const utter = new SpeechSynthesisUtterance(part[cIndex]);
          utter.rate = SPEECH_RATE;
          setTimeout(() => window.speechSynthesis.speak(utter), 0);

          cIndex++;
          this.charTimeout = setTimeout(speakNextChar, delay);
        };

        speakNextChar();
      }
    };

    speakNextPart();
  }
}

const Speech = new SpeechManager();

/**************************************************************
 *                    ENGINE MANAGER
 **************************************************************/

/**
 * Manages communication with the Stockfish chess engine.
 */
class EngineManager {
  /**
   * @param {(bestMove: string) => void} onMoveCallback - Callback when engine suggests a move.
   * @param {() => void} onMateCallback - Callback when checkmate is detected.
   */
  constructor(onMoveCallback, onMateCallback) {
    this.worker = new Worker("stockfish.js");
    this.suggestedMove = null;
    this.sideToMove = "white";

    this.worker.onmessage = (event) => {
      const data = event?.data;
      if (!data) return;

      if (data.startsWith("bestmove")) {
        this.suggestedMove = data.split(" ")[1];
        onMoveCallback(this.suggestedMove);
      }

      if (data.includes("score mate 0")) {
        onMateCallback();
      }
    };

    ["uci", "isready", "ucinewgame"].forEach(cmd => this.worker.postMessage(cmd));
  }

  /**
   * Sets the engine's position based on moves played.
   * @param {string[]} moves - Array of moves in standard algebraic notation.
   */
  setPosition(moves) {
    this.worker.postMessage(`position startpos moves ${moves.join(" ")}`);
  }

  /**
   * Requests the engine to compute the next move.
   * @param {string[]} moves - Array of moves played so far.
   */
  requestMove(moves) {
    this.setPosition(moves);
    this.sideToMove = moves.length % 2 === 0 ? "white" : "black";
    const depth = Math.min(5 + moves.length * 2, 15);
    this.worker.postMessage(`go depth ${depth}`);
  }
}

let GameEngine = null;

/**************************************************************
 *                     GAME STATE
 **************************************************************/

/**
 * Represents the current state of the game and input.
 */
class GameState {
  constructor() {
    /** @type {STATES} */
    this.state = STATES.CONSTRUCTING;
    /** @type {string[]} List of moves made */
    this.moves = [];
    /** @type {string[]} List of removed moves for undo/redo */
    this.removedMoves = [];
    /** @type {string[]} Current coordinate input */
    this.coordinates = [];
    /** @type {number} Current numeric coordinate */
    this.currentCoordinate = 0;
    /** @type {boolean} Whether input is temporarily locked */
    this.inputLocked = false;
    /** @type {ReturnType<typeof setTimeout>|null} Timer for coordinate input */
    this.coordinateTimer = null;
    /** @type {ReturnType<typeof setTimeout>|null} Timer for post-thinking approval */
    this.postThinkingTimer = null;
    /** @type {number} Timestamp of last key press */
    this.lastPressTime = 0;
    /** @type {number|null} Timestamp of first post-thinking key press */
    this.firstPostPressTime = null;
  }

  /** Resets coordinate input to initial state. */
  resetInput() {
    this.state = STATES.CONSTRUCTING;
    this.coordinates = [];
    this.currentCoordinate = 0;
    this.firstPostPressTime = null;
  }

  /**
   * Maps a numeric input to a board coordinate.
   * @param {number} index - Index of the coordinate (0-3).
   * @param {number} value - Numeric value (1-8).
   * @returns {string|null} Board coordinate or null if invalid.
   */
  mapCoordinate(index, value) {
    if (value < 1 || value > MAX_COORD_VALUE) return null;
    return index % 2 === 0 ? "abcdefgh"[value - 1] : String(value);
  }

  /** Finalizes the current coordinate input and possibly makes a move. */
  finalizeCoordinate() {
    const mapped = this.mapCoordinate(this.coordinates.length, this.currentCoordinate);
    if (!mapped) return;

    this.coordinates.push(mapped);
    this.currentCoordinate = 0;

    if (this.coordinates.length === 4) {
      const move = this.coordinates.join("");
      const color = this.moves.length % 2 === 0 ? "white" : "black";

      Speech.speak(`*Go* ${toNatoString(move)} *${color}*`);
      this.moves.push(move);
      this.removedMoves = [];

      GameEngine.requestMove(this.moves);
      this.inputLocked = true;
      this.state = STATES.THINKING;
    } else {
      Speech.speak(`*Does* ${toNatoString(this.coordinates.join(""))}`);
    }
  }
}

const Game = new GameState();

/**************************************************************
 *                     INPUT & TIMERS
 **************************************************************/

/** Starts or resets the coordinate input timer. */
function startCoordinateTimer() {
  clearTimeout(Game.coordinateTimer);
  Game.coordinateTimer = setTimeout(() => Game.finalizeCoordinate(), COORD_VALIDATE_DELAY);
}

/** Starts the post-thinking approval timer. */
function startPostThinkingTimer() {
  Speech.speak("*Approve?*");
  clearTimeout(Game.postThinkingTimer);
  Game.postThinkingTimer = setTimeout(() => {
    acceptEngineMove();
    Game.firstPostPressTime = null;
  }, ENGINE_APPROVE_DELAY);
}

/**************************************************************
 *                        ACTIONS
 **************************************************************/

/**
 * Cancels current input and resets the game state.
 * @param {string} [message="*Cancelled*"] - Optional speech message.
 */
function cancelAll(message = "*Cancelled*") {
  Speech.speak(message);
  clearTimeout(Game.coordinateTimer);
  clearTimeout(Game.postThinkingTimer);
  Game.inputLocked = true;
  setTimeout(() => Game.inputLocked = false, INPUT_UNLOCK_DELAY);
  Game.resetInput();
}

/** Accepts the engine's suggested move. */
function acceptEngineMove() {
  if (!GameEngine.suggestedMove) return;
  Speech.speak("*Approved.*");
  Game.moves.push(GameEngine.suggestedMove);
  Game.removedMoves = [];
  GameEngine.suggestedMove = null;
  GameEngine.requestMove(Game.moves);
  Game.inputLocked = true;
  Game.state = STATES.THINKING;
}

/** Rejects the engine's move and starts a new input. */
function rejectEngineMoveStartNew() {
  Game.state = STATES.CONSTRUCTING;
  Game.coordinates = [];
  Game.currentCoordinate = 0;
  Speech.speak("*Disapproved.*");
}

/**************************************************************
 *                    INPUT HANDLING
 **************************************************************/

/** Handles input during the CONSTRUCTING state. */
function handleConstructingInput() {
  const now = performance.now();
  const delta = now - Game.lastPressTime;
  Game.lastPressTime = now;

  if (delta < COORD_VALIDATE_DELAY || Game.currentCoordinate === 0) {
    Game.currentCoordinate++;
    if (Game.currentCoordinate === 9) return cancelAll();

    const mapped = Game.mapCoordinate(Game.coordinates.length, Game.currentCoordinate);
    Speech.speak(toNatoString(mapped ?? ""));
  }
  startCoordinateTimer();
}

/** Handles input during the POST_THINKING state. */
function handlePostThinkingInput() {
  const now = performance.now();
  if (Game.firstPostPressTime === null) {
    Game.firstPostPressTime = now;
    startPostThinkingTimer();
    return;
  }

  if (now - Game.firstPostPressTime < ENGINE_APPROVE_DELAY) {
    clearTimeout(Game.postThinkingTimer);
    rejectEngineMoveStartNew();
  }
}

/** Main input handler. Delegates to state-specific handlers. */
function handleInput() {
  if (Game.inputLocked) return;

  switch (Game.state) {
    case STATES.CONSTRUCTING: return handleConstructingInput();
    case STATES.POST_THINKING: return handlePostThinkingInput();
    case STATES.THINKING: return; // ignore input
  }
}

/**************************************************************
 *                    ENGINE CALLBACKS
 **************************************************************/
GameEngine = new EngineManager(
  (bestMove) => {
    Game.inputLocked = false;
    Speech.speak(`*Best ${GameEngine.sideToMove}*${toNatoString(bestMove)}`);
    Game.state = STATES.POST_THINKING;
    Game.firstPostPressTime = null;
  },
  () => Speech.speak("*Checkmate!*")
);

/**************************************************************
 *                     KEYBOARD EVENTS
 **************************************************************/
const KEY_ACTIONS = {
  Space: handleInput,
  ArrowLeft: undoMove,
  ArrowRight: redoMove,
  ArrowUp: repeatSpeech
};

document.addEventListener("keydown", (event) => {
  const action = KEY_ACTIONS[event.code];
  if (action) {
    event.preventDefault();
    action();
  }
});

/**************************************************************
 *                     UNDO/REDO
 **************************************************************/

/** Undo the last move. */
function undoMove() {
  if (!Game.moves.length) return;

  const removed = Game.moves.pop();
  Game.removedMoves.push(removed);

  const last = Game.moves.length ? Game.moves[Game.moves.length - 1] : "";
  cancelAll(
    `*removed ${(Game.moves.length % 2 === 0 ? "white* " : "black* ")}${toNatoString(removed)} *last move* ${toNatoString(last)}`
  );
}

/** Redo the last undone move. */
function redoMove() {
  if (!Game.removedMoves.length) return;

  const added = Game.removedMoves.pop();
  Game.moves.push(added);
  cancelAll(`*added ${(Game.moves.length % 2 === 0 ? "black* " : "white* ")}${toNatoString(added)}`);
}

/** Repeats the last spoken text. */
function repeatSpeech() {
  Speech.speak(Speech.lastSpoken);
}
  </script>
</body>
</html>
