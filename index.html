<!DOCTYPE html>
<html>
<body>
  <script>
/**************************************************************
 *                      CONSTANTS
 **************************************************************/
const STATES = {
  CONSTRUCTING: "constructing",
  THINKING: "thinking",
  POST_THINKING: "postThinking",
};

/* ---------------- GLOBAL SPEED CONTROLS ---------------- */
const GAME_SPEED = 1.0;     // 1 = normal, 2 = twice as fast, 0.5 = half speed
const SPEECH_RATE = 1.0 * GAME_SPEED;    // speech speed scales with GAME_SPEED

// Helper to scale all time-based delays
function sped(ms) {
  return ms / GAME_SPEED;
}

/* ---------------- BASE DELAYS (unscaled) ---------------- */
const BASE_COORD_VALIDATE_DELAY = 1000;
const BASE_ENGINE_APPROVE_DELAY = 2000;
const BASE_INPUT_UNLOCK_DELAY   = 1000;
const BASE_VOICE_DELAY          = 300;

const COORD_VALIDATE_DELAY = sped(BASE_COORD_VALIDATE_DELAY);
const ENGINE_APPROVE_DELAY = sped(BASE_ENGINE_APPROVE_DELAY);
const INPUT_UNLOCK_DELAY   = sped(BASE_INPUT_UNLOCK_DELAY);
const VOICE_DELAY          = BASE_VOICE_DELAY / SPEECH_RATE;

const MAX_COORD_VALUE = 8;


/**************************************************************
 *                      SPEECH MANAGER
 **************************************************************/
class SpeechManager {
  constructor() {
    this.sessionId = 0;
    this.charTimeout = null;
    this.lastSpoken = "";
  }

  static toNatoStarString(str) {
    const nato = {
      a: "alpha", b: "bravo", c: "charlie", d: "delta",
      e: "echo", f: "foxtrot", g: "golf", h: "hotel",
      i: "india", j: "juliett", k: "kilo", l: "lima",
      m: "mike", n: "november", o: "oscar", p: "papa",
      q: "quebec", r: "romeo", s: "sierra", t: "tango",
      u: "uniform", v: "victor", w: "whiskey", x: "xray",
      y: "yankee", z: "zulu"
    };

    return str
      .toLowerCase()
      .split("")
      .map(ch => nato[ch] ? `*${nato[ch]}*` : ch)
      .join("");
  }

  speak(text, delay = VOICE_DELAY) {
    if (!text) return;

    this.lastSpoken = text;
    console.log(text);

    // Cancel any ongoing speech
    window.speechSynthesis.cancel();

    // Unique session to prevent overlap
    this.sessionId++;
    const session = this.sessionId;

    // Clear timeout from previous session
    if (this.charTimeout) {
      clearTimeout(this.charTimeout);
      this.charTimeout = null;
    }

    const parts = text.split("*");
    let pIndex = 0;

    const speakNextPart = () => {
      if (session !== this.sessionId) return;
      if (pIndex >= parts.length) return;

      const part = parts[pIndex];
      const isNormal = (pIndex % 2 === 1);
      pIndex++;

      if (isNormal) {
        const utter = new SpeechSynthesisUtterance(part);
        utter.rate = SPEECH_RATE;
        utter.onend = speakNextPart;
        setTimeout(() => window.speechSynthesis.speak(utter), 0);
        return;
      }

      let cIndex = 0;
      const speakNextChar = () => {
        if (session !== this.sessionId) return;
        if (cIndex >= part.length) {
          speakNextPart();
          return;
        }

        const utter = new SpeechSynthesisUtterance(part[cIndex]);
        utter.rate = SPEECH_RATE;
        setTimeout(() => window.speechSynthesis.speak(utter), 0);

        cIndex++;
        this.charTimeout = setTimeout(speakNextChar, delay);
      };

      speakNextChar();
    };

    setTimeout(speakNextPart, 0);
  }
}

const Speech = new SpeechManager();



/**************************************************************
 *                    ENGINE MANAGER
 **************************************************************/
class EngineManager {
  constructor(onMoveCallback, onMateCallback) {
    this.worker = new Worker("stockfish.js");
    this.suggestedMove = null;
    this.sideToMove = "white";

    this.worker.onmessage = (event) => {
      const data = event?.data;
      if (!data) return;

      if (data.startsWith("bestmove")) {
        const move = data.split(" ")[1];
        this.suggestedMove = move;
        onMoveCallback(move);
        return;
      }

      if (data.includes("score mate 0")) {
        onMateCallback();
      }
    };

    this.worker.postMessage("uci");
    this.worker.postMessage("isready");
    this.worker.postMessage("ucinewgame");
  }

  setPosition(moves) {
    this.worker.postMessage(`position startpos moves ${moves.join(" ")}`);
  }

  requestMove(moves) {
    this.setPosition(moves);
    this.sideToMove = (moves.length % 2 === 0 ? "white" : "black");

    const depth = Math.min(5 + moves.length * 2, 15);
    this.worker.postMessage(`go depth ${depth}`);
  }
}

let GameEngine = null;



/**************************************************************
 *                     GAME STATE MANAGER
 **************************************************************/
class GameState {
  constructor() {
    this.state = STATES.CONSTRUCTING;
    this.moves = [];
    this.removedMoves = [];

    this.coordinates = [];
    this.currentCoordinate = 0;

    this.lastPressTime = 0;
    this.firstPostPressTime = null;

    this.inputLocked = false;

    this.coordinateTimer = null;
    this.postThinkingTimer = null;
  }

  resetInput() {
    this.state = STATES.CONSTRUCTING;
    this.coordinates = [];
    this.currentCoordinate = 0;
    this.firstPostPressTime = null;
  }

  mapCoordinate(index, value) {
    if (value < 1 || value > MAX_COORD_VALUE) return null;

    return (index % 2 === 0)
      ? "abcdefgh"[value - 1]
      : String(value);
  }

  finalizeCoordinate() {
    const mapped = this.mapCoordinate(this.coordinates.length, this.currentCoordinate);
    if (!mapped) return;

    this.coordinates.push(mapped);
    this.currentCoordinate = 0;

    // Completed move
    if (this.coordinates.length === 4) {
      const move = this.coordinates.join("");

      Speech.speak(
        "*Go* " +
        SpeechManager.toNatoStarString(move) +
        (this.moves.length % 2 === 0 ? " *white*" : " *black*")
      );

      this.moves.push(move);
      this.removedMoves = [];

      GameEngine.requestMove(this.moves);

      this.inputLocked = true;
      this.state = STATES.THINKING;

    } else {
      Speech.speak("*Does* " + SpeechManager.toNatoStarString(this.coordinates.join("")));
    }
  }
}

const Game = new GameState();



/**************************************************************
 *                   INPUT & TIMER LOGIC
 **************************************************************/
function startCoordinateTimer() {
  clearTimeout(Game.coordinateTimer);
  Game.coordinateTimer = setTimeout(
    () => Game.finalizeCoordinate(),
    COORD_VALIDATE_DELAY
  );
}

function startPostThinkingTimer() {
  Speech.speak("*Approve?*");
  clearTimeout(Game.postThinkingTimer);

  Game.postThinkingTimer = setTimeout(() => {
    acceptEngineMove();
    Game.firstPostPressTime = null;
  }, ENGINE_APPROVE_DELAY);
}



/**************************************************************
 *                        ACTIONS
 **************************************************************/
function cancelAll(message = "*Cancelled*") {
  Speech.speak(message);

  clearTimeout(Game.coordinateTimer);
  clearTimeout(Game.postThinkingTimer);

  Game.inputLocked = true;
  setTimeout(() => Game.inputLocked = false, INPUT_UNLOCK_DELAY);

  Game.resetInput();
}

function acceptEngineMove() {
  if (!GameEngine.suggestedMove) return;

  Speech.speak("*Approved.*");
  Game.moves.push(GameEngine.suggestedMove);
  Game.removedMoves = [];
  GameEngine.suggestedMove = null;

  GameEngine.requestMove(Game.moves);

  Game.inputLocked = true;
  Game.state = STATES.THINKING;
}

function rejectEngineMoveStartNew() {
  Game.state = STATES.CONSTRUCTING;
  Game.coordinates = [];
  Game.currentCoordinate = 0;
  Speech.speak("*Disapproved.*");
}





/**************************************************************
 *                     MAIN INPUT HANDLER
 **************************************************************/
function handleInput() {
  if (Game.inputLocked) return;

  const now = performance.now();
  const delta = now - Game.lastPressTime;
  Game.lastPressTime = now;

  switch (Game.state) {
    case STATES.CONSTRUCTING: {
      if (delta < COORD_VALIDATE_DELAY || Game.currentCoordinate === 0) {
        Game.currentCoordinate++;
        if (Game.currentCoordinate === 9) return cancelAll();

        const mapped = Game.mapCoordinate(Game.coordinates.length, Game.currentCoordinate);
        Speech.speak(SpeechManager.toNatoStarString(mapped ?? ""));
      }
      startCoordinateTimer();
      break;
    }

    case STATES.THINKING:
      // Input ignored
      break;

    case STATES.POST_THINKING: {
      if (Game.firstPostPressTime === null) {
        Game.firstPostPressTime = now;
        startPostThinkingTimer();
        return;
      }

      const since = now - Game.firstPostPressTime;

      if (since < ENGINE_APPROVE_DELAY) {
        clearTimeout(Game.postThinkingTimer);
        rejectEngineMoveStartNew();
      }
      break;
    }
  }
}



/**************************************************************
 *                    ENGINE CALLBACKS
 **************************************************************/
GameEngine = new EngineManager(
  (bestMove) => {
    Game.inputLocked = false;
    Speech.speak(
      "*Best " +
      GameEngine.sideToMove +
      "*" +
      SpeechManager.toNatoStarString(bestMove)
    );

    Game.state = STATES.POST_THINKING;
    Game.firstPostPressTime = null;
  },
  () => Speech.speak("*Checkmate!*")
);



/**************************************************************
 *                   KEYBOARD EVENTS
 **************************************************************/
document.addEventListener("keydown", (event) => {

  if (event.code === "Space") {
    event.preventDefault();
    handleInput();
  }

  if (event.code === "ArrowLeft") {
    event.preventDefault();

    if (Game.moves.length === 0) return;

    const removed = Game.moves.pop();
    Game.removedMoves.push(removed);

    const last = Game.moves.length ? Game.moves[Game.moves.length - 1] : "";
    cancelAll(
      "*removed " +
      (Game.moves.length % 2 === 0 ? "white* " : "black* ") +
      SpeechManager.toNatoStarString(removed) +
      " *last move* " +
      SpeechManager.toNatoStarString(last)
    );
  }

  if (event.code === "ArrowRight" && Game.removedMoves.length) {
    event.preventDefault();
    const added = Game.removedMoves.pop();
    Game.moves.push(added);
    cancelAll(
      "*added " +
      (Game.moves.length % 2 === 0 ? "black* " : "white* ") +
      SpeechManager.toNatoStarString(added)
    );
  }

  if (event.code === "ArrowUp") {
    event.preventDefault();
    Speech.speak(Speech.lastSpoken);
  }
});
  </script>
</body>
</html>
