<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Board container automatically scales to fit */
    #board-wrapper {
      width: min(90vw, 90vh);
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #board {
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      position: relative;
      border: 4px solid #000;
    }

    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 5vmin;
      font-family: serif;
      user-select: none;
    }

    .light { background: #eee; }
    .dark  { background: #779; color: white; }

    .highlight {
      outline: 4px solid yellow;
      z-index: 2;
    }

    .piece.white {
      color: white;
      -webkit-text-stroke: 1px black; 
      text-stroke: 1px black;
    }
    .piece.black { color: black; }

    /* Coordinates around board */
    .coord {
      position: absolute;
      font-size: 2vmin;
      font-family: sans-serif;
      color: #ccc;
      pointer-events: none;
    }
    .file-label { bottom: -3%; }
    .rank-label { left: -3%; }
  </style>
</head>

<body>
  <div id="board-wrapper">
    <div id="board"></div>
  </div>
  <script src="chess.js"></script>
  <script>
/**************************************************************
 *                      CONSTANTS
 **************************************************************/

/**
 * Possible states of the game.
 * @readonly
 * @enum {string}
 */
const STATES = Object.freeze({
  CONSTRUCTING: "constructing",
  THINKING: "thinking",
  POST_THINKING: "postThinking",
});

/**
 * Base timeout durations (in milliseconds).
 * @readonly
 */
const TIMEOUTS = Object.freeze({
  BASE_COORD_VALIDATE: 1000,
  BASE_ENGINE_APPROVE: 1000,
  BASE_INPUT_UNLOCK: 1000,
  BASE_VOICE: 300,
});

const GAME_SPEED = 1.0;
const SPEECH_RATE = 1.0 * GAME_SPEED;

const MAX_COORD_VALUE = 8;

const COORD_VALIDATE_DELAY = TIMEOUTS.BASE_COORD_VALIDATE / GAME_SPEED;
const ENGINE_APPROVE_DELAY = TIMEOUTS.BASE_ENGINE_APPROVE / GAME_SPEED;
const INPUT_UNLOCK_DELAY   = TIMEOUTS.BASE_INPUT_UNLOCK / GAME_SPEED;
const VOICE_DELAY          = TIMEOUTS.BASE_VOICE / SPEECH_RATE;

/**************************************************************
 *                      UTILS
 **************************************************************/

/**
 * Sleep for a given duration.
 * @param {number} ms - Duration in milliseconds.
 * @returns {Promise<void>}
 */
const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

/**
 * Converts a string to NATO phonetic alphabet notation.
 * Letters are wrapped in `*` for special pronunciation.
 * @param {string} str - The input string.
 * @returns {string} - NATO phonetic representation.
 */
const toNatoString = (str) => {
  const nato = {
    a: "alpha", b: "bravo", c: "charlie", d: "delta",
    e: "echo", f: "foxtrot", g: "golf", h: "hotel",
    i: "india", j: "juliett", k: "kilo", l: "lima",
    m: "mike", n: "november", o: "oscar", p: "papa",
    q: "quebec", r: "romeo", s: "sierra", t: "tango",
    u: "uniform", v: "victor", w: "whiskey", x: "xray",
    y: "yankee", z: "zulu"
  };

  return str
    .toLowerCase()
    .split("")
    .map(ch => nato[ch] ? `*${nato[ch]}*` : ch)
    .join("");
};

/**************************************************************
 *                      SPEECH MANAGER
 **************************************************************/

/**
 * Manages speech synthesis for the game.
 */
class SpeechManager {
  constructor() {
    /** @type {number} Unique session id to prevent speech overlap */
    this.sessionId = 0;
    /** @type {ReturnType<typeof setTimeout>|null} Timeout for character-by-character speech */
    this.charTimeout = null;
    /** @type {string} Last spoken text */
    this.lastSpoken = "";
  }

  /**
   * Speak a text string with optional character-by-character delays.
   * @param {string} text - The text to speak.
   * @param {number} [delay=VOICE_DELAY] - Delay between characters in milliseconds.
   */
  speak(text, delay = VOICE_DELAY) {
    if (!text) return;

    this.lastSpoken = text;
    console.log(text);

    window.speechSynthesis.cancel();
    this.sessionId++;
    const session = this.sessionId;

    if (this.charTimeout) clearTimeout(this.charTimeout);

    const parts = text.split("*");
    let pIndex = 0;

    const speakNextPart = () => {
      if (session !== this.sessionId || pIndex >= parts.length) return;

      const part = parts[pIndex];
      const isNormal = (pIndex % 2 === 1);
      pIndex++;

      if (isNormal) {
        const utter = new SpeechSynthesisUtterance(part);
        utter.rate = SPEECH_RATE;
        utter.onend = speakNextPart;
        setTimeout(() => window.speechSynthesis.speak(utter), 0);
      } else {
        let cIndex = 0;
        const speakNextChar = () => {
          if (session !== this.sessionId || cIndex >= part.length) {
            speakNextPart();
            return;
          }

          const utter = new SpeechSynthesisUtterance(part[cIndex]);
          utter.rate = SPEECH_RATE;
          setTimeout(() => window.speechSynthesis.speak(utter), 0);

          cIndex++;
          this.charTimeout = setTimeout(speakNextChar, delay);
        };

        speakNextChar();
      }
    };

    speakNextPart();
  }
}

const Speech = new SpeechManager();

/**************************************************************
 *                    ENGINE MANAGER
 **************************************************************/

/**
 * Manages communication with the Stockfish chess engine.
 */
class EngineManager {
  /**
   * @param {(bestMove: string) => void} onMoveCallback - Callback when engine suggests a move.
   * @param {() => void} onMateCallback - Callback when checkmate is detected.
   */
  constructor(onMoveCallback, onMateCallback) {
    this.worker = new Worker("stockfish.js");
    this.suggestedMove = null;
    this.sideToMove = "white";

    this.worker.onmessage = (event) => {
      const data = event?.data;
      if (!data) return;

      if (data.startsWith("bestmove")) {
        this.suggestedMove = data.split(" ")[1];
        onMoveCallback(this.suggestedMove);
      }

      if (data.includes("score mate 0")) {
        onMateCallback();
      }
    };

    ["uci", "isready", "ucinewgame"].forEach(cmd => this.worker.postMessage(cmd));
  }

  /**
   * Sets the engine's position based on moves played.
   * @param {string[]} moves - Array of moves in standard algebraic notation.
   */
  setPosition(moves) {
    this.worker.postMessage(`position startpos moves ${moves.join(" ")}`);
  }

  /**
   * Requests the engine to compute the next move.
   * @param {string[]} moves - Array of moves played so far.
   */
  requestMove(moves) {
    this.setPosition(moves);
    this.sideToMove = moves.length % 2 === 0 ? "white" : "black";
    const depth = Math.min(5 + moves.length * 2, 15);
    this.worker.postMessage(`go depth ${depth}`);
  }
}

let GameEngine = null;

/**************************************************************
 *                     GAME STATE
 **************************************************************/

/**
 * Represents the current state of the game and input.
 */
class GameState {
  constructor() {
    /** @type {STATES} */
    this.state = STATES.CONSTRUCTING;
    /** @type {string[]} List of moves made */
    this.moves = [];
    /** @type {string[]} List of removed moves for undo/redo */
    this.removedMoves = [];
    /** @type {string[]} Current coordinate input */
    this.coordinates = [];
    /** @type {number} Current numeric coordinate */
    this.currentCoordinate = 0;
    /** @type {boolean} Whether input is temporarily locked */
    this.inputLocked = false;
    /** @type {ReturnType<typeof setTimeout>|null} Timer for coordinate input */
    this.coordinateTimer = null;
    /** @type {ReturnType<typeof setTimeout>|null} Timer for post-thinking approval */
    this.postThinkingTimer = null;
    /** @type {number} Timestamp of last key press */
    this.lastPressTime = 0;
    /** @type {number|null} Timestamp of first post-thinking key press */
    this.firstPostPressTime = null;
    this.chess = new Chess();
  }

  /** Resets coordinate input to initial state. */
  resetInput() {
    this.state = STATES.CONSTRUCTING;
    this.coordinates = [];
    this.currentCoordinate = 0;
    this.firstPostPressTime = null;
  }

  /**
   * Maps a numeric input to a board coordinate.
   * @param {number} index - Index of the coordinate (0-3).
   * @param {number} value - Numeric value (1-8).
   * @returns {string|null} Board coordinate or null if invalid.
   */
  mapCoordinate(index, value) {
    if (value < 1 || value > MAX_COORD_VALUE) return null;
    return index % 2 === 0 ? "abcdefgh"[value - 1] : String(value);
  }

  /** Finalizes the current coordinate input and possibly makes a move. */
  finalizeCoordinate() {
    const mapped = this.mapCoordinate(this.coordinates.length, this.currentCoordinate);
    if (!mapped) return;

    this.coordinates.push(mapped);
    this.currentCoordinate = 0;

    if (this.coordinates.length === 4) {
      const move = this.coordinates.join("");
      const color = this.moves.length % 2 === 0 ? "white" : "black";

      // Convert to chess.js move object
      const moveObj = {
        from: move.slice(0, 2),
        to: move.slice(2, 4),
        promotion: "q" // optional default promotion
      };

      // Check if move is legal
      const result = this.chess.move(moveObj);

      if (!result) {
        cancelAll("*Illegal move*"); // move rejected
        return;
      }

      // Move is valid, update game
      Speech.speak(`*Go* ${toNatoString(move)} *${color}*`);
      this.moves.push(move);
      this.removedMoves = [];

      updateBoard();
      GameEngine.requestMove(this.moves);
      this.inputLocked = true;
      this.state = STATES.THINKING;
    } else {
      Speech.speak(`*Does* ${toNatoString(this.coordinates.join(""))}`);
    }
  }
}

const Game = new GameState();

/**************************************************************
 *                     INPUT & TIMERS
 **************************************************************/

/** Starts or resets the coordinate input timer. */
function startCoordinateTimer() {
  clearTimeout(Game.coordinateTimer);
  Game.coordinateTimer = setTimeout(() => Game.finalizeCoordinate(), COORD_VALIDATE_DELAY);
}

/** Starts the post-thinking approval timer. */
function startPostThinkingTimer() {
  Speech.speak("*Approve?*");
  clearTimeout(Game.postThinkingTimer);
  Game.postThinkingTimer = setTimeout(() => {
    acceptEngineMove();
    Game.firstPostPressTime = null;
  }, ENGINE_APPROVE_DELAY);
}

/**************************************************************
 *                        ACTIONS
 **************************************************************/

/**
 * Cancels current input and resets the game state.
 * @param {string} [message="*Cancelled*"] - Optional speech message.
 */
function cancelAll(message = "*Cancelled*") {
  Speech.speak(message);
  clearTimeout(Game.coordinateTimer);
  clearTimeout(Game.postThinkingTimer);
  Game.inputLocked = true;
  setTimeout(() => Game.inputLocked = false, INPUT_UNLOCK_DELAY);
  Game.resetInput();
}

/** Accepts the engine's suggested move. */
function acceptEngineMove() {
  if (!GameEngine.suggestedMove) return;

  const move = GameEngine.suggestedMove;

  // Apply move to chess.js
  const moveObj = {
    from: move.slice(0, 2),
    to: move.slice(2, 4),
    promotion: move.length === 5 ? move[4] : "q" // handle promotions if present
  };
  const result = Game.chess.move(moveObj);
  if (!result) {
    Speech.speak("*Illegal engine move*");
    return;
  }

  // Update game state
  Speech.speak("*Approved.*");
  Game.moves.push(move);
  Game.removedMoves = [];
  GameEngine.suggestedMove = null;

  updateBoard();
  GameEngine.requestMove(Game.moves);
  Game.inputLocked = true;
  Game.state = STATES.THINKING;
}

/** Rejects the engine's move and starts a new input. */
function rejectEngineMoveStartNew() {
  Game.state = STATES.CONSTRUCTING;
  Game.coordinates = [];
  Game.currentCoordinate = 0;
  Speech.speak("*Disapproved.*");
  updateBoard();
}

/**************************************************************
 *                    INPUT HANDLING
 **************************************************************/

/** Handles input during the CONSTRUCTING state. */
function handleConstructingInput() {
  const now = performance.now();
  const delta = now - Game.lastPressTime;
  Game.lastPressTime = now;

  if (delta < COORD_VALIDATE_DELAY || Game.currentCoordinate === 0) {
    Game.currentCoordinate++;
    if (Game.currentCoordinate === 9) return cancelAll();

    const mapped = Game.mapCoordinate(Game.coordinates.length, Game.currentCoordinate);
    Speech.speak(toNatoString(mapped ?? ""));
  }
  startCoordinateTimer();
}

/** Handles input during the POST_THINKING state. */
function handlePostThinkingInput() {
  const now = performance.now();
  if (Game.firstPostPressTime === null) {
    Game.firstPostPressTime = now;
    startPostThinkingTimer();
    return;
  }

  if (now - Game.firstPostPressTime < ENGINE_APPROVE_DELAY) {
    clearTimeout(Game.postThinkingTimer);
    rejectEngineMoveStartNew();
  }
}

/** Main input handler. Delegates to state-specific handlers. */
function handleInput() {
  if (Game.inputLocked) return;

  switch (Game.state) {
    case STATES.CONSTRUCTING: return handleConstructingInput();
    case STATES.POST_THINKING: return handlePostThinkingInput();
    case STATES.THINKING: return; // ignore input
  }
}

/**************************************************************
 *                    ENGINE CALLBACKS
 **************************************************************/
GameEngine = new EngineManager(
  (bestMove) => {
    Game.inputLocked = false;
    Speech.speak(`*Best ${GameEngine.sideToMove}*${toNatoString(bestMove)}`);
    Game.state = STATES.POST_THINKING;
    Game.firstPostPressTime = null;
  },
  () => Speech.speak("*Checkmate!*")
);

/**************************************************************
 *                     KEYBOARD EVENTS
 **************************************************************/
const KEY_ACTIONS = {
  Space: handleInput,
  ArrowLeft: undoMove,
  ArrowRight: redoMove,
  ArrowUp: repeatSpeech,
  ArrowDown: () => location.reload()
};

document.addEventListener("keydown", (event) => {
  const action = KEY_ACTIONS[event.code];
  if (action) {
    event.preventDefault();
    action();
  }
});

/**************************************************************
 *                     UNDO/REDO
 **************************************************************/

/** Undo the last move. */
function undoMove() {
  if (!Game.moves.length) return;

  // Undo in chess.js
  const undoneMove = Game.chess.undo();
  if (!undoneMove) return;

  // Remove from moves array
  const removed = Game.moves.pop();
  Game.removedMoves.push(removed);

  // Speech feedback
  const last = Game.moves.length ? Game.moves[Game.moves.length - 1] : "";
  cancelAll(
    `*removed ${(Game.moves.length % 2 === 0 ? "white* " : "black* ")}${toNatoString(removed)} *last move* ${toNatoString(last)}`
  );

  updateBoard();
}

/** Redo the last undone move. */
function redoMove() {
  if (!Game.removedMoves.length) return;

  const added = Game.removedMoves.pop();

  // Redo in chess.js
  const moveObj = {
    from: added.slice(0, 2),
    to: added.slice(2, 4),
    promotion: "q"
  };
  const result = Game.chess.move(moveObj);

  if (!result) {
    // Illegal redo (shouldn't happen)
    Speech.speak("*Cannot redo move*");
    return;
  }

  // Add to moves array
  Game.moves.push(added);
  cancelAll(`*added ${(Game.moves.length % 2 === 0 ? "black* " : "white* ")}${toNatoString(added)}`);

  updateBoard();
}

/** Repeats the last spoken text. */
function repeatSpeech() {
  Speech.speak(Speech.lastSpoken);
}

/**************************************************************
 *                    BOARD RENDER LOGIC
 **************************************************************/

const PIECES = {
  p: "♟",
  r: "♜",
  n: "♞",
  b: "♝",
  q: "♛",
  k: "♚"
};


function initialBoard() {
  return [
    ["b.r","b.n","b.b","b.q","b.k","b.b","b.n","b.r"],
    ["b.p","b.p","b.p","b.p","b.p","b.p","b.p","b.p"],
    ["","","","","","","",""],
    ["","","","","","","",""],
    ["","","","","","","",""],
    ["","","","","","","",""],
    ["w.p","w.p","w.p","w.p","w.p","w.p","w.p","w.p"],
    ["w.r","w.n","w.b","w.q","w.k","w.b","w.n","w.r"]
  ];
}

function sqToRC(sq) {
  const file = sq.charCodeAt(0) - 97;
  const rank = 8 - Number(sq[1]);
  return { r: rank, c: file };
}

function applyMove(board, move, color) {
  const from = sqToRC(move.slice(0,2));
  const to   = sqToRC(move.slice(2,4));

  const piece = board[from.r][from.c];
  board[from.r][from.c] = "";

  if (move.length === 5) {
    const promo = move[4];
    board[to.r][to.c] = `${color}.${promo}`;
  } else {
    board[to.r][to.c] = piece;
  }
}

function renderBoard(boardMatrix) {
  const board = document.getElementById("board");
  board.innerHTML = "";

  // Render 64 squares
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const div = document.createElement("div");
      div.className = "square " + ((r + c) % 2 ? "dark" : "light");

      const piece = boardMatrix[r][c];
      if (piece) {
        const [color, type] = piece.split(".");
        div.textContent = PIECES[type];
        div.classList.add("piece", color === "w" ? "white" : "black");
      }

      div.dataset.rank = r;
      div.dataset.file = c;

      board.appendChild(div);
    }
  }

  // Coordinates
  const files = "abcdefgh".split("");
  const ranks = "87654321".split("");

  for (let i = 0; i < 8; i++) {
    // file label
    let f = document.createElement("div");
    f.className = "coord file-label";
    f.style.left = ((i + 0.5) * 12.5) + "%";
    f.textContent = files[i];
    board.appendChild(f);

    // rank label
    let r = document.createElement("div");
    r.className = "coord rank-label";
    r.style.top = ((i + 0.5) * 12.5) + "%";
    r.textContent = ranks[i];
    board.appendChild(r);
  }

  // Highlight last move
  const moves = Game.moves;
  if (moves.length) {
    const move = moves[moves.length - 1];
    const from = sqToRC(move.slice(0,2));
    const to   = sqToRC(move.slice(2,4));

    const squares = [...board.children];
    squares.forEach(sq => {
      if (+sq.dataset?.rank === from.r && +sq.dataset?.file === from.c)
        sq.classList.add("highlight");
      if (+sq.dataset?.rank === to.r   && +sq.dataset?.file === to.c)
        sq.classList.add("highlight");
    });
  }
}

function updateBoard() {
  let board = initialBoard();

  Game.moves.forEach((move, index) => {
    const color = index % 2 === 0 ? "w" : "b";
    applyMove(board, move, color);
  });

  renderBoard(board);
}

/**************************************************************
 *                    INIT DISPLAY
 **************************************************************/

updateBoard();
  </script>
</body>
</html>
